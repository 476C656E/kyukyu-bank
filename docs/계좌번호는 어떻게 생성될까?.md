# 계좌번호는 어떻게 생성될까?
뱅킹 서비스 프로젝트를 시작하기 앞서, 첫 관문이 계좌번호다.
계좌를 개설하면, 은행에서 자동으로 계좌번호를 부여해줬는데, 이 과정은 어떻게 이루어지는지 알아보며 계좌생성 기능을 구현하려고 한다.

## 1. 개요
계좌번호는 은행 시스템에서 중요한 식별자이다. 그러므로 다양한 특성이 존재할텐데, 해당 프로젝트에선 고유성, 검증과 확장성을 고려한다.

### 일반적인 은행 계좌번호 구조
실제 은행들은 다음과 같은 요소들을 조합하여 계좌번호를 생성한다고 한다.
```
[상품코드(3-4자리)] - [지점코드(3-4자리)] - [일련번호(5-7자리)] - [검증번호(1자리)]
```
각 요소의 의미이다.
- **A**: 고객 구분
- **B**: 고객(관리) 번호
- **N**: 난수
- **S**: 단축 코드
- **T**: 계좌 구분
- **Y**: 계좌 종류 (과목)
- **Z**: 일련번호
- **C**: 검증번호

큐큐뱅크 뱅킹서비스 프로젝트에서는 실제 은행과 유사하되 단순화된 형식을 채택했다.
계좌 (상품, 과목), 일련번호, 검증번호
**YYYZ-ZZZZ-ZZZC** (총 12자리, 4-4-4 그룹화) "오.. 어디서 많이 본 형식인데? ㅋㅋ"

## 2. 계좌 번호
### 2. 1 계좌 종류 설계 - Y
현재는 타행 송금까지 생각하고 있지만, 다른 기능들도 학습할 예정이라 확장성을 위해 미리 계좌 타입을 설계했다.
```kotlin
enum class AccountType(
    val accountTypeCode: String  // 3자리 계좌종류 코드 (계좌번호 생성용)
) {
    DEPOSIT("100"),           // 입출금
    FIXED_DEPOSIT("200"),     // 정기예금
    SAVING("300"),            // 적금
    FOREIGN_CURRENCY("400")   // 외화
}
```

### 2.2 일련번호 구성 - Z
일련번호는 고객의 식별자와 같은데, 해당 프로젝트에선 MySQL의 Auto_increment를 활용하여 순차적으로 부여한다.
실제 은행에서는 다른 알고리즘이 존재할 수 있는데. 해당 프로젝트에선 오버엔지니어링이라고 생각되고, 순차적 할당이면 충분히 고유성을 보장할 수 있다고 생각한다.
- **범위**: 00000001 ~ 99999999
- **용량**: 최대 약 1억 개의 계좌 생성 가능
- **패딩**: 항상 8자리로 0 패딩 (예: 1 → 00000001)
- **생성 방식**: MySQL AUTO_INCREMENT를 사용한 시퀀스 테이블

### 2.3 검증번호 - C
검증번호는 마지막 1 자리인데, 계좌번호 입력 및 데이터 무결성을 보장하기 위해 존재한다.
계좌번호를 수동으로 입력하는데, 휴먼 에러(전치 및 오타)를 방지하여, 잘못된 계좌로 송금되는 문제를 보장한다.
검증번호는 특정 알고리즘(Luhn, 모듈러) 또는 자체 알고리즘 으로 계산하여 생성한다는데, 모듈러를 채택한 이유는 단순하다. 
-> 검증번호 제외하면 11자리라서 11을 모듈로 연산하면 되기에... (혼나겠넹... 알고리즘 분석 할 시간이 없었습니다 ㅠㅠ 하나의 빠른 트레이드오프...)

- **범위**: 0 ~ 9 (1자리 숫자)
- **알고리즘**: Modulo
- **목적**: 계좌번호 입력 오류 감지
- **자동 생성**: 계좌종류 + 일련번호를 기반으로 자동 계산

### 계좌번호 설계 정리
큐큐뱅크 계좌개설에 계좌번호 할당은 다음과도 같이 할당된다.
```
입출금 계좌 (일련번호 1):        1000-0000-0013
정기예금 계좌 (일련번호 12345678): 2001-2345-6785
적금 계좌 (일련번호 87654321):    3008-7654-3217
외화 계좌 (일련번호 50000000):    4005-0000-0003
```

## 3. 핵심 구현
### 3.1 검증번호 계산기
자, 그러면 이제 계좌번호를 생성하는 기능을 구현해야한다.
계좌종류는 정해져있고, 일련번호는 순차적 할당이기에, 채택한 모듈로 연산을 사용하여 검증번호 계산기부터 구현한다.

#### 모듈로 연산란?
모듈러인가..? 하여튼 모듈로 연산은 간단하게 어떤 숫자를 다른 숫자로 나눴을 때 남는 나머지를 구하는 계산이다. 즉 %를 사용하면된다. (오 쉽네 ㅋ)
쉬운 예시로서, 시간을 오전, 오후와 24시간제로 나타내는 경우가 있다. 14시는 오후 2시인데 여기서 모듈로 연산의 핵심을 알 수 있다.
(14 % 12 = 2) 즉, 24시간제를 오전(12), 오후(12)이니까 12로 나누면 몫이 1이고 나머지가 2이다. 그래서 오후 2시 인거다.

뭐 모듈로 연산은 데이터 분산(해싱)등에도 사용되는데 이건 다음에 알아보고... 다시 돌아가자면 ?

11 자리의 배열이 필요한데 이걸 가중치 배열이라고 부르겠다.
진짜 단순하게 생각하면 가중치를 모아놓은 배열 여기서 가중치는 중요도, 영향력등을 고려하면된다.

**가중치 배열**: `[2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6]`
오른쪽부터 왼쪽으로 적용되는데, 여기선 수학적 특성이 존재한다고 한다.
오른쪽부터 계산하면 자릿수가 증가할 때 패턴이 일정하게 반복된다고한다.
실제 국내 1은행 사례를 보면, 11 12 13 14 15 16 11 12 처럼 반복 패턴을 가지는데,
오른쪽으로 적용하면 이 패턴이 자연스럽게 확장된다.

**계산 단계**:
1. 계좌종류(3자리) + 일련번호(8자리) = 11자리 추출
2. 오른쪽부터 왼쪽으로 각 자리에 가중치 곱셈
3. 모든 곱셈 결과 합산
4. 합계를 11로 나눈 나머지 계산
5. `(11 - 나머지) % 11` 계산
6. 결과가 10이면 0으로 변환 (1자리 유지)

**계산 예시**:
```
계좌번호 prefix: 10000000001 (입출금 계좌, 일련번호 1)

자리수:  1  0  0  0  0  0  0  0  0  0  1
가중치:  6  5  4  3  2  7  6  5  4  3  2
곱셈:    6  0  0  0  0  0  0  0  0  0  2

합계: 6 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 2 = 8
나머지: 8 % 11 = 8
검증번호: (11 - 8) % 11 = 3

최종 계좌번호: 1000-0000-0013
```

#### 구현 코드

```kotlin
@Component
object CheckDigitCalculator {

    private val WEIGHTS = intArrayOf(2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6)

    // 계좌번호의 앞 11자리를 기반으로 검증번호를 계산한다
    fun calculate(accountNumberPrefix: String): Int {
        // 하이픈 제거 및 유효성 검사
        val digits = accountNumberPrefix.replace("-", "")
        require(digits.length == 11) { "계좌번호는 11자리여야 해요" }
        require(digits.all { it.isDigit() }) { "계좌번호는 숫자만 포함해야 해요" }

        // 오른쪽부터 왼쪽으로 가중치 적용하여 합산한다
        var sum = 0
        for (i in digits.indices) {
            val digit = digits[digits.length - 1 - i].digitToInt()
            sum += digit * WEIGHTS[i]
        }

        // 11 Modulo 연산
        val remainder = sum % 11
        val checkDigit = (11 - remainder) % 11

        // 10이면 0으로 변환 (1자리 숫자로 유지)
        return if (checkDigit == 10) 0 else checkDigit
    }
}
```

---

### 3.2 AccountNumberGenerator: 계좌번호 생성기
이제, 검증 로직은 해결됐으니, 계좌 타입과 일련번호를 받아 완전한 계좌번호를 생성해야한다.
먼저 코드를 보자면 일련번호 검증은, 하나의 시퀀스 테이블을 사용하기에 유효 범위를 지정했다.
만약, 별도의 시퀀스 테이블을 사용하면 4억개까지 생성할 수 있어보이는데... 실제 은행에서는 어떻게 하는지는 잘 모르겠다.

```kotlin
@Component("accountNumberGenerator")
object AccountNumberGenerator {

    // 계좌 타입과 시퀀스 번호를 기반으로 12자리 계좌번호를 생성한다. (DB 저장용)
    fun generate(accountType: AccountType, sequenceNumber: Long): String {
        require(sequenceNumber in 1..99999999) {
            "일련번호는 1부터 99999999 사이여야 해요: $sequenceNumber"
        }

        // 계좌종류 코드 (3자리) + 일련번호 (8자리)
        val accountTypeCode = accountType.accountTypeCode
        val serialNumber = sequenceNumber.toString().padStart(8, '0')
        val prefix = accountTypeCode + serialNumber

        // 검증번호 계산
        val checkDigit = CheckDigitCalculator.calculate(prefix)

        // 전체 12자리 계좌번호
        return prefix + checkDigit
    }

    // 계좌번호의 유효성을 검증한다.
    fun validate(accountNumber: String): Boolean {
        return CheckDigitCalculator.validate(accountNumber)
    }
}
```

#### 생성 프로세스

```
1. 입력 검증
   ├─ sequenceNumber는 1~99999999 범위인가?
   └─ 범위 벗어나면 IllegalArgumentException 발생

2. 계좌종류 코드 추출
   └─ accountType.accountTypeCode (예: "100")

3. 일련번호 8자리 패딩
   └─ sequenceNumber.toString().padStart(8, '0')
   └─ 예: 1 → "00000001"

4. 11자리 prefix 생성
   └─ accountTypeCode + serialNumber
   └─ 예: "100" + "00000001" = "10000000001"

5. 검증번호 계산
   └─ CheckDigitCalculator.calculate(prefix)
   └─ 예: "10000000001" → 3

6. 12자리 전체 번호 생성
   └─ prefix + checkDigit
   └─ 예: "10000000001" + "3" = "100000000013"
```

---

## 4. 실제 사용 예시

### 4.1 전체 플로우

```
[사용자 요청: 계좌 개설]
         ↓
[AccountService.createAccount()]
         ↓
[1] accountRepository.getNextAccountNumberSequence()
    → INSERT INTO account_number_sequence
    → SELECT LAST_INSERT_ID()
    → 반환: 1L
         ↓
[2] accountNumberGenerator.generate(DEPOSIT, 1L)
    ├─ accountTypeCode = "100"
    ├─ serialNumber = "00000001"
    ├─ prefix = "10000000001"
    ├─ checkDigit = CheckDigitCalculator.calculate("10000000001") → 3
    └─ return "1000-0000-0013"
         ↓
[3] accountRepository.save(account)
    → DB 저장
         ↓
[계좌 생성 완료]
```

### 4.2 코드 예시

```kotlin
// AccountService.kt
@Transactional
fun createAccount(newAccount: NewAccount): Long {
    val sequenceNumber = accountRepository.getNextAccountNumberSequence()
    val accountNumber = accountNumberGenerator.generate(newAccount.type, sequenceNumber)

    if (accountRepository.existsByAccountNumber(accountNumber)) {
        throw CoreException(ErrorType.DUPLICATE_ACCOUNT_NUMBER)
    }

    val saved = accountRepository.save(
        AccountEntity(
            userId = newAccount.userId,
            accountNumber = accountNumber,
            accountPassword = newAccount.accountPassword,
            bankCode = BankCode.KYUKYU_BANK.code,
            type = newAccount.type,
            currency = newAccount.currency,
            status = AccountStatus.ACTIVE,
            balance = BigDecimal.ZERO,
        )
    )

    return saved.id
}
```

---

## 5. 테스트

### 5.1 CheckDigitCalculatorTest

검증번호 계산 알고리즘의 정확성을 위해 테스트를 구현한다.

**주요 테스트 케이스 (총 14개)**:

| 테스트 | 목적 | 예시 |
|--------|------|------|
| 정상 케이스 | 기본 검증번호 계산 | `"10000000001"` → 3 |
| 다양한 일련번호 | 여러 계좌 타입 검증 | 100, 200, 300, 400 |
| 결과가 10인 경우 | 0으로 변환 확인 | checkDigit ∈ [0, 9] |
| 유효성 검증 - 올바른 번호 | validate() 성공 | `"100000000013"` → true |
| 유효성 검증 - 잘못된 검증번호 | validate() 실패 | `"100000000019"` → false |
| 잘못된 길이 | 11자리 아닌 경우 거부 | `"10000000001"` (11자리) → false |
| 숫자 아닌 문자 | 알파벳 포함 거부 | `"100A0000001B"` → false |
| 예외 발생 - 짧은 입력 | IllegalArgumentException | `"1000000001"` (10자리) |
| 예외 발생 - 긴 입력 | IllegalArgumentException | `"100000000001"` (12자리) |
| 전체 시나리오 | 생성 → 검증 플로우 | calculate() + validate() |

---

### 5.2 AccountNumberGeneratorTest

계좌번호 생성 전체 프로세스를 테스트를 구현한다.

**주요 테스트 케이스 (총 15개)**:

| 테스트 | 목적 | 검증 내용 |
|--------|------|-----------|
| 입출금 계좌번호 생성 | DEPOSIT 정상 생성 | 100으로 시작, 14자리 |
| 정기예금 계좌번호 생성 | FIXED_DEPOSIT 정상 생성 | 200으로 시작 |
| 적금 계좌번호 생성 | SAVING 정상 생성 | 300으로 시작 |
| 외화 계좌번호 생성 | FOREIGN_CURRENCY 정상 생성 | 400으로 시작 |
| 시퀀스 번호 8자리 패딩 | 패딩 정확성 | 1 → "00000001" |
| 모든 계좌 타입 검증 | 4가지 타입 모두 생성 | 100, 200, 300, 400 |
| 검증번호 유효성 | 생성된 계좌번호 검증 | validate() 통과 |
| 계좌번호 구조 | 구성 요소 분리 | 계좌종류 3자리 + 일련번호 8자리 + 검증번호 1자리 |
| 범위 초과 일련번호 | 100000000 거부 | IllegalArgumentException |
| 범위 미달 일련번호 | 0 거부 | IllegalArgumentException |
| 최소 일련번호 | 경계값 1 | "00000001" 포함 |
| 최대 일련번호 | 경계값 99999999 | "99999999" 포함 |
| 전체 시나리오 | 4가지 타입 생성 및 검증 | 하이픈 포함/미포함 모두 검증 |

**테스트 코드 예시**:
```kotlin
@Test
fun `입출금 계좌번호를 정상적으로 생성한다`() {
    // given
    val accountType = AccountType.DEPOSIT
    val sequenceNumber = 1L

    // when
    val accountNumber = AccountNumberGenerator.generate(accountType, sequenceNumber)

    // then
    assertTrue(accountNumber.startsWith("100"))
    assertEquals(14, accountNumber.length)  // 12자리 + 하이픈 2개
    assertTrue(accountNumber.matches(Regex("\\d{4}-\\d{4}-\\d{4}")))
}

```

---

## 6. 아키텍처 및 구현 결정

### 6.1 시퀀스 테이블 방식 선택

#### 왜 별도 시퀀스 테이블을 사용할까?

계좌번호 일련번호 생성을 위해 `account_number_sequence` 테이블을 별도로 두는 이유는 **비즈니스 로직과 데이터 모델의 분리** 때문이다.

1. **AccountEntity.id와 계좌번호 일련번호는 목적이 다르다**
   ```
   AccountEntity.id     → DB 내부 식별자 (Primary Key)
   계좌번호 일련번호     → 비즈니스 식별자 (사용자에게 노출)
   ```
   - `id`는 단순히 레코드를 구분하는 기술적 식별자
   - 계좌번호는 검증번호, 타입 코드 등 비즈니스 로직이 포함된 복합 식별자

2. **트랜잭션 롤백과 시퀀스의 독립성**
   ```kotlin
   // 시나리오: 계좌 생성 중 비즈니스 검증 실패
   @Transactional
   fun createAccount() {
       val seq = getNextSequence()  // 5번 발급
       val account = createAccount(seq)
       validate(account)  // 실패 → 롤백
       // 시퀀스 5는 사용되지 않음 (갭 발생)
   }
   ```
   - 계좌 엔티티는 롤백되어야 하지만
   - 시퀀스는 이미 발급되었으므로 되돌릴 수 없음
   - 별도 테이블로 관리하여 책임 분리

3. **확장성 및 유연성**
   - 향후 계좌 타입별 별도 시퀀스 관리 가능
   - 시퀀스 초기화, 재설정 등 운영 작업 용이
   - 감사(Audit) 추적 가능 (`created_at` 컬럼)


---

### 6.2 Repository 구조 설계

#### Custom Repository 추가

```kotlin
interface AccountRepository : JpaRepository<AccountEntity, Long>, AccountRepositoryCustom
```

네이티브 쿼리와 JPA 쿼리를 별도로 분리하기 위해 커스텀 메서드를 추가했다.

```
AccountRepository (인터페이스)
├─ JpaRepository<AccountEntity, Long>
│  └─ 기본 CRUD: save(), findById(), delete() 등
│
└─ AccountRepositoryCustom (커스텀 인터페이스)
   └─ getNextAccountNumberSequence(): Long
      └─ AccountRepositoryImpl에서 구현
```

#### AccountRepositoryCustom

```kotlin
interface AccountRepositoryCustom {
    fun getNextAccountNumberSequence(): Long
}
```

- 네이티브 쿼리가 필요한 메서드를 별도 인터페이스로 분리
- Spring Data JPA 네이밍 규칙으로 해결 불가능한 로직 처리
- 테스트 시 모킹(Mocking) 용이

#### AccountRepositoryImpl

```kotlin
@Repository
class AccountRepositoryImpl(
    private val entityManager: EntityManager
) : AccountRepositoryCustom {

    @Transactional
    override fun getNextAccountNumberSequence(): Long {
        // 시퀀스 테이블에 새 레코드 삽입
        entityManager.createNativeQuery("INSERT INTO account_number_sequence VALUES ()")
            .executeUpdate()

        // 마지막 삽입된 ID 반환
        return entityManager.createNativeQuery("SELECT LAST_INSERT_ID()")
            .singleResult as Long
    }
}
```

**메서드 상세 설명**:

1. **@Transactional**
   - 트랜잭션 내에서 실행 보장
   - INSERT와 SELECT가 원자적으로 수행

2. **INSERT INTO account_number_sequence VALUES ()**
   - 빈 레코드 삽입
   - AUTO_INCREMENT가 자동으로 id 값 생성
   - MySQL 테이블 레벨 락으로 동시성 보장

3. **SELECT LAST_INSERT_ID()**
   - 현재 **세션(커넥션)에서** 마지막으로 삽입된 AUTO_INCREMENT 값 반환
   - 다른 세션의 INSERT와 무관 (세션별로 독립적)
   - 동시 요청이 와도 각자의 LAST_INSERT_ID() 유지

**왜 두 개의 쿼리로 분리했을까?**
- INSERT와 SELECT를 하나의 쿼리로 합칠 수 없음
- LAST_INSERT_ID()는 현재 세션의 컨텍스트에서만 유효
- 명시적으로 분리하여 동작 의도 명확화

#### 기본 Repository 메서드들

```kotlin
interface AccountRepository : JpaRepository<AccountEntity, Long>, AccountRepositoryCustom {
    fun existsByAccountNumber(accountNumber: String): Boolean
    fun findByUserId(userId: Long, slice: Pageable): Slice<AccountEntity>
    fun findByUserIdAndId(userId: Long, accountId: Long): AccountEntity
}
```

---

### 6.3 트랜잭션 및 동시성 처리

#### AUTO_INCREMENT의 원자성

**동시 요청 시나리오**:
```
시간 →  사용자 A           사용자 B           사용자 C
T1     INSERT (id=1)
T2                        INSERT (id=2)
T3                                          INSERT (id=3)
T4     LAST_INSERT_ID()→1
T5                        LAST_INSERT_ID()→2
T6                                          LAST_INSERT_ID()→3
```

**보장되는 것**:
- ✅ 각 세션은 **고유한 시퀀스 번호**를 받음
- ✅ AUTO_INCREMENT는 **테이블 레벨 락**으로 원자적으로 증가
- ✅ LAST_INSERT_ID()는 **세션별로 독립적**

**보장되지 않는 것**:
- ❌ 일련번호의 **연속성** (갭 발생 가능)

#### 갭(Gap) 발생 시나리오

**트랜잭션 롤백**:
```kotlin
트랜잭션 A: 시퀀스 5 받음 → 계좌 생성 실패 → 롤백
트랜잭션 B: 시퀀스 6 받음 → 계좌 생성 성공
결과: 일련번호 4 → 6 (5는 영구 결번)
```

**왜 이런 설계일까?**
- AUTO_INCREMENT는 **성능을 위해** 롤백 시 되돌리지 않음
- 만약 되돌린다면:
  - 모든 트랜잭션이 시퀀스 획득을 기다려야 함 (직렬화)
  - 동시성 성능 급격히 저하

**중요한 것**:
- ✅ **유일성 보장** (중복 없음)
- ❌ **연속성 보장 안됨** (갭 허용)

#### 전체 플로우에서의 트랜잭션

```kotlin
@Transactional
fun createAccount(newAccount: NewAccount): Long {
    // 1. 시퀀스 획득 (별도 트랜잭션 or 같은 트랜잭션)
    val sequenceNumber = accountRepository.getNextAccountNumberSequence()

    // 2. 계좌번호 생성 (비즈니스 로직)
    val accountNumber = accountNumberGenerator.generate(newAccount.type, sequenceNumber)

    // 3. 중복 체크
    if (accountRepository.existsByAccountNumber(accountNumber)) {
        throw CoreException(ErrorType.DUPLICATE_ACCOUNT_NUMBER)
    }

    // 4. 계좌 저장
    val saved = accountRepository.save(
        AccountEntity(
            userId = newAccount.userId,
            accountNumber = accountNumber,
            // ... 기타 필드
        )
    )

    return saved.id
}
```

**트랜잭션 경계**:
```
외부 트랜잭션 시작 (@Transactional)
├─ getNextAccountNumberSequence() 실행
│  ├─ 내부 트랜잭션 시작 (@Transactional)
│  ├─ INSERT INTO account_number_sequence
│  ├─ SELECT LAST_INSERT_ID()
│  └─ 내부 트랜잭션 커밋
│
├─ 계좌번호 생성 (generate)
├─ 중복 체크 (existsByAccountNumber)
├─ 계좌 엔티티 저장 (save)
└─ 외부 트랜잭션 커밋 (또는 롤백)
```

**롤백 시 동작**:
- 계좌 엔티티: ✅ 롤백됨 (저장 취소)
- 시퀀스 레코드: ❌ 롤백 안됨 (이미 커밋됨)
- 결과: 시퀀스 갭 발생

---

## 7. 성능 및 확장성

### 7.1 성능 특성

#### 시퀀스 생성 성능

**쿼리 분석**:
```sql
-- 1. 시퀀스 레코드 삽입 (AUTO_INCREMENT)
INSERT INTO account_number_sequence VALUES ()

-- 2. 마지막 ID 조회
SELECT LAST_INSERT_ID()
```

**성능 지표**:
- INSERT: O(1) - 인덱스 업데이트 없음 (PK만 존재)
- LAST_INSERT_ID(): O(1) - 세션 변수 조회
- 테이블 레벨 락: 매우 짧은 시간 (밀리초 이하)

**병목 가능성**:
- 초당 수천 건 이상의 계좌 생성 요청 시
- AUTO_INCREMENT 락 경합 발생 가능
- 해결책: Redis INCR, PostgreSQL SEQUENCE 등 검토

| 항목    | MySQL AUTO_INCREMENT | Redis INCR         | PostgreSQL SEQUENCE | Snowflake ID |
  |-------|----------------------|--------------------|---------------------|--------------|
| 성능    | 중 (수천 TPS)           | 매우 높음 (수만~수십만 TPS) | 높음 (CACHE 사용 시)     | 매우 높음        |
| 확장성   | 단일 DB 의존             | Redis 클러스터         | 단일 DB 의존            | 완전 분산        |
| 복잡도   | 낮음                   | 중 (인프라 추가)         | 중 (DB 변경)           | 높음 (워커 관리)   |
| 연속성   | 갭 발생                 | 갭 발생               | 갭 발생 (CACHE)        | 시간순, 연속 아님   |
| DB 의존 | 높음                   | 낮음                 | 높음                  | 없음           |

Redis INCR

특징:
- 메모리 기반 원자적 증가 연산 (INCR 커맨드)
- 성능: 마이크로초 단위로 매우 빠름 (MySQL보다 10~100배 빠름)
- 단일 스레드 이벤트 루프로 동시성 안전 보장
- 영속성: RDB/AOF 스냅샷으로 데이터 보존 가능

장점:
- 초당 수만~수십만 건 처리 가능
- 분산 락 없이도 원자성 보장

단점:
- 메모리 기반이라 서버 장애 시 복구 전략 필요
- Redis 인프라 추가 필요

  ---
PostgreSQL SEQUENCE

특징:
- DB 네이티브 시퀀스 객체 (MySQL과 달리 별도 객체)
- CACHE 옵션: 메모리에 미리 할당하여 성능 향상
- 트랜잭션과 독립적으로 증가 (롤백해도 되돌아가지 않음)
- 여러 테이블에서 공유 가능

장점:
- MySQL AUTO_INCREMENT보다 유연함
- CACHE 100 설정 시 락 경합 100배 감소
- 직접 제어 가능 (ALTER SEQUENCE로 재설정)

단점:
- MySQL에서 PostgreSQL로 DB 변경 필요

예시:
CREATE SEQUENCE account_number_seq
START WITH 1
INCREMENT BY 1
CACHE 100;  -- 100개씩 미리 할당

  ---
Snowflake ID (추가 제안)

특징:
- Twitter에서 개발한 분산 ID 생성 알고리즘
- 구조: 타임스탬프(41bit) + 워커ID(10bit) + 시퀀스(12bit) = 64bit
- 시간순 정렬 가능 (첫 부분이 타임스탬프)
- DB 의존성 없음

장점:
- 완전 분산 환경에서 동작 (각 서버가 독립적으로 생성)
- 충돌 없이 초당 409만 개 생성 가능 (워커당)
- DB 부하 제로

단점:
- 워커 ID 관리 필요
- 서버 시간 동기화 중요 (NTP)

#### 데이터베이스 부하

**시퀀스 테이블 증가**:
```sql
-- 1억 계좌 생성 시
SELECT COUNT(*) FROM account_number_sequence;
-- 결과: 100,000,000 rows
```

**관리 방안**:
- 주기적 데이터 삭제 (AUTO_INCREMENT 값은 유지됨)
- 파티셔닝 고려 (연도별, 분기별)
- 아카이빙 전략 수립

---

### 7.2 한계점 및 트레이드오프

#### 확장성 한계

**일련번호 범위**:
```kotlin
require(sequenceNumber in 1..99999999) {
    "일련번호는 1부터 99999999 사이여야 해요"
}
```
- 최대 9,999만 개 계좌 생성 가능
- 초과 시 시스템 재설계 필요

**해결 방안**:
- 계좌 타입별 별도 시퀀스 테이블 → 약 4억 개
- 일련번호 자릿수 확장 (9자리 → 10자리)
- 지점 코드 추가하여 분산

#### 단일 장애점 (SPOF)

**현재 구조**:
```
모든 계좌 생성 요청
    ↓
account_number_sequence 테이블
    ↓
단일 AUTO_INCREMENT
```

**리스크**:
- 테이블 락 경합 시 모든 계좌 생성 지연
- DB 장애 시 계좌 생성 불가

**개선 방향**:
- 분산 시퀀스 생성 (Redis, Snowflake ID 등)
- DB 복제 및 읽기/쓰기 분리
- 비동기 계좌 생성 큐 도입

#### 연속성 미보장

**갭 발생 원인**:
1. 트랜잭션 롤백
2. 서버 재시작 (InnoDB는 일부 시퀀스 스킵)
3. 동시 요청 처리 순서

**비즈니스 영향**:
- 일반적으로 문제없음 (은행도 허용)
- 감사/회계 시 갭 발생 이유 설명 필요
- 통계 분석 시 COUNT 기반 추정 부정확

---

### 7.3 고려 사항

- [ ] 부하 테스트로 성능 병목 지점 정량 측정
- [ ] 시퀀스 생성 로직을 별도 서비스로 분리
- [ ] 검증번호 오류 감지율 통계 수집

- [ ] JPA @TableGenerator 또는 @SequenceGenerator 도입 검토
- [ ] 성능 개선 효과 측정 (TPS, 응답 시간)
- [ ] PostgreSQL 지원 추가 (멀티 DB 지원)

- [ ] Redis 기반 분산 시퀀스 도입 검토
- [ ] 계좌번호 형식 확장 (지점 코드, 상품 세부 코드 등)
- [ ] 검증번호 알고리즘 다양화 (Luhn, Modulo 10 등)

---

## 참고 자료

- [ISO/IEC 7064: Check character systems](https://www.iso.org/standard/31531.html)
- [Modulo 11 Algorithm](https://en.wikipedia.org/wiki/Check_digit#Modulo_11)
- [JPA Identifier Generation Strategies](https://docs.oracle.com/javaee/7/api/javax/persistence/GenerationType.html)
- [MySQL AUTO_INCREMENT](https://dev.mysql.com/doc/refman/8.0/en/example-auto-increment.html)
