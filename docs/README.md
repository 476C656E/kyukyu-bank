# 토스뱅크 송금 학습용 프로젝트

이 프로젝트는 한국 토스뱅크에서 타행 계좌로 돈을 송금하는 기능을 학습하기 위한 샘플 프로젝트입니다.

## 프로젝트 구조

이 프로젝트는 다음과 같은 서비스로 구성됩니다.

- **banking-service**: 핵심 뱅킹 로직을 처리하는 서비스입니다.
- **external-bank**: 외부 은행 시스템을 시뮬레이션하는 서비스입니다.
- **client**: 사용자가 송금 요청을 보낼 수 있는 웹 프론트엔드입니다.

## 시작하기

각 서비스의 README 파일을 참고하여 프로젝트를 시작할 수 있습니다.

---

## 프로젝트 핵심 엔티티 설계

이 문서는 토스뱅크 송금 학습용 프로젝트의 핵심 엔티티인 `유저(User)`, `계좌(Account)`, `거래(Transaction)`, `은행(Bank)`에 대해 상세히 기술합니다.

---

### 1. 유저 (User)

#### 1.1. 역할 및 책임
- 서비스의 주체이며, 모든 자산(계좌)과 활동(거래)의 소유자입니다.
- 인증을 통해 식별되며, 자신의 계좌를 조회하고 송금 거래를 시작할 수 있는 유일한 주체입니다.

#### 1.2. 설계 근거
- **선택 이유**: 금융 서비스에서 '누가'의 개념은 필수적입니다. 모든 계좌는 소유주가 있어야 하며, 모든 거래는 요청자가 있어야 합니다. 유저 엔티티는 이러한 소유권과 행위의 주체를 명확히 정의하기 위해 반드시 필요합니다.
- **역할의 중요성**: 유저가 없다면 계좌나 거래 기록이 누구의 것인지 알 수 없어 시스템이 성립되지 않습니다.

#### 1.3. 상세 필드

| 필드명 | 데이터 타입 | 설명 | 필수 여부 |
| --- | --- | --- | --- |
| `userId` | Long | 유저의 고유 식별자 (Primary Key) | Y |
| `name` | String | 사용자의 실명 | Y |
| `email` | String | 로그인 및 알림을 위한 이메일 주소 (Unique) | Y |
| `password` | String | 해싱하여 저장된 비밀번호 | Y |
| `createdAt` | DateTime | 계정 생성 일시 | Y |
| `updatedAt` | DateTime | 마지막 정보 수정 일시 | Y |

---

### 2. 계좌 (Account)

#### 2.1. 역할 및 책임
- 유저가 소유한 자산을 보관하는 가상의 '금고'입니다.
- 입금, 출금, 송금 등 모든 금융 거래의 시작점 또는 종착점 역할을 합니다.
- 계좌는 반드시 특정 유저(User)에게 소속됩니다.

#### 2.2. 설계 근거
- **선택 이유**: 돈(자산)을 구체적인 숫자로 표현하고 관리하기 위한 핵심 엔티티입니다. 유저 엔티티만으로는 자산을 관리할 수 없으므로, 자산의 양(잔액)과 고유한 식별자(계좌번호)를 가진 계좌 엔티티가 필요합니다.
- **대안 비교**: 유저 엔티티에 `balance` 필드를 직접 포함하는 방식을 고려할 수 있으나, 이는 확장성에 매우 불리합니다. 한 명의 유저가 여러 개의 계좌(예: 주계좌, 파킹통장)를 가질 수 있는 현실 세계의 요구사항을 반영하려면 계좌 엔티티를 분리하는 것이 올바른 설계입니다.

#### 2.3. 상세 필드

| 필드명 | 데이터 타입 | 설명 | 필수 여부 |
| --- | --- | --- | --- |
| `accountId` | Long | 계좌의 고유 식별자 (Primary Key) | Y |
| `userId` | Long | 계좌 소유주의 식별자 (Foreign Key) | Y |
| `accountNumber` | String | 사용자에게 노출되는 고유 계좌번호 (Unique) | Y |
| `balance` | BigDecimal | 계좌 잔액. **부동소수점 오류를 피하기 위해 반드시 BigDecimal 사용** | Y |
| `bankCode` | String | 이 계좌가 속한 은행의 코드 (이 프로젝트에서는 'kyukyu-bank' 고정) | Y |
| `status` | Enum | 계좌 상태 (예: `ACTIVE`, `INACTIVE`, `CLOSED`) | Y |
| `createdAt` | DateTime | 계좌 개설 일시 | Y |
| `updatedAt` | DateTime | 마지막 거래 또는 정보 수정 일시 | Y |

---

### 3. 거래 (Transaction)

#### 3.1. 역할 및 책임
- 계좌 간의 자금 이동을 기록하는 '거래 원장'입니다.
- 모든 송금 요청은 하나의 거래로 기록되며, 이 기록은 시간이 지나도 불변(Immutable)해야 합니다.
- 거래의 상태(요청, 성공, 실패)를 추적하여 안정적인 송금 처리를 보장합니다.

#### 3.2. 설계 근거
- **선택 이유**: 단순히 계좌의 잔액만 변경하는 것은 '왜' 돈이 바뀌었는지에 대한 기록을 남기지 못합니다. 거래 엔티티는 모든 자금 변동에 대한 명확한 근거와 이력을 제공하며, 문제 발생 시 추적과 복구의 기준이 됩니다.
- **역할의 중요성**: 거래 기록이 없다면 사용자는 자신의 돈이 어떻게 사용되었는지 알 수 없으며, 은행은 자금 흐름을 증명할 수 없습니다.

#### 3.3. 상세 필드

| 필드명 | 데이터 타입 | 설명 | 필수 여부 |
| --- | --- | --- | --- |
| `transactionId` | Long | 거래의 고유 식별자 (Primary Key) | Y |
| `fromAccountId` | Long | 출금된 계좌의 ID (Foreign Key) | Y |
| `toBankCode` | String | 입금될 은행의 코드 | Y |
| `toAccountNumber` | String | 입금될 계좌의 번호 | Y |
| `amount` | BigDecimal | 거래 금액 | Y |
| `status` | Enum | 거래 상태 (예: `REQUESTED`, `SUCCESS`, `FAILED`) | Y |
| `transactionType` | Enum | 거래 종류 (예: `TRANSFER`, `DEPOSIT`, `WITHDRAWAL`) | Y |
| `transactionDate` | DateTime | 거래 발생 일시 | Y |

---

### 4. 은행 (Bank)

#### 4.1. 역할 및 책임
- 송금이 가능한 타행 금융기관의 목록을 관리합니다.
- 사용자가 송금할 은행을 선택할 때 목록을 제공하고, 입력된 은행 코드의 유효성을 검증하는 기준 정보를 제공합니다.

#### 4.2. 설계 근거
- **선택 이유**: 타행 송금 시, 목적지 은행이 유효한지 확인하는 절차는 필수적입니다. 은행 엔티티는 이러한 '화이트리스트' 역할을 수행하여 시스템의 안정성을 높입니다.
- **대안 비교**: 은행 목록을 코드 내에 하드코딩(예: Enum)하는 방식을 고려할 수 있습니다.
    - **Enum 방식**: 간단하고 빠르지만, 지원 은행이 추가/삭제될 때마다 애플리케이션을 새로 빌드하고 배포해야 합니다.
    - **엔티티(DB) 방식**: 데이터베이스에 저장하여 유연성을 확보할 수 있습니다. 애플리케이션 재배포 없이 은행 목록을 수정할 수 있어 운영에 유리합니다. 학습용 프로젝트에서는 둘 다 가능하지만, 실제 서비스에 가까운 설계를 위해 엔티티로 분리하는 것이 더 좋은 학습 경험을 제공합니다.

#### 4.3. 상세 필드

| 필드명 | 데이터 타입 | 설명 | 필수 여부 |
| --- | --- | --- | --- |
| `bankCode` | String | 은행의 고유 코드 (Primary Key, 예: "088") | Y |
| `bankName` | String | 은행 이름 (예: "신한은행") | Y |
| `isActive` | Boolean | 현재 송금 가능한 은행인지 여부 | Y |

---

## 주요 사용자 시나리오 (Happy Path)

아래는 사용자가 서비스를 이용하는 가장 일반적인 흐름을 나타냅니다.

1.  **회원가입**: '김규규'라는 이름의 사용자가 이메일과 비밀번호를 입력하여 서비스에 가입합니다.
2.  **로그인**: 가입한 이메일과 비밀번호로 로그인합니다.
3.  **계좌 개설**: 로그인 후, '내 계좌' 메뉴에서 '계좌 만들기'를 선택합니다. 시스템은 `111-222-333333`과 같은 고유한 계좌번호를 부여하고, 초기 잔액은 0원입니다.
4.  **초기 자금 입금 (가정)**: 시나리오의 편의를 위해, 김규규 사용자는 자신의 계좌에 외부로부터 100,000원을 입금했다고 가정합니다. 현재 잔액: 100,000원.
5.  **타행 송금 시도**: 김규규 사용자는 친구에게 30,000원을 송금하기로 합니다.
    -   송금 화면에서 자신의 출금 계좌(`111-222-333333`)를 선택합니다.
    -   받는 사람의 은행으로 '신한은행'을 선택합니다.
    -   받는 사람의 계좌번호 `888-777-666666`과 보낼 금액 30,000원을 입력합니다.
    -   '보내기' 버튼을 클릭합니다.
6.  **송금 처리 및 결과 확인**:
    -   `banking-service`는 `external-bank`에 수취인 계좌의 유효성을 확인합니다.
    -   유효하다는 응답을 받으면, 김규규 사용자의 계좌에서 30,000원을 차감합니다. (잔액: 70,000원)
    -   송금이 성공적으로 완료되었다는 메시지를 사용자에게 보여줍니다.
7.  **거래 내역 조회**: 김규규 사용자는 자신의 계좌 상세 페이지에서 '거래 내역'을 조회합니다. 방금 보낸 30,000원의 송금 기록이 최상단에 표시된 것을 확인합니다.

---

## banking-service 개발 요구사항

`banking-service`는 전체 송금 프로세스의 핵심 로직을 담당하는 주체로서, 아래의 요구사항을 만족해야 합니다.

### 기능적 요구사항 (Functional Requirements)

1.  **사용자 관리 (단순화)**
    -   [ ] 사용자는 최소한의 정보(이메일, 비밀번호, 이름)로 회원가입을 할 수 있어야 합니다.
    -   [ ] 사용자는 이메일과 비밀번호로 로그인할 수 있어야 합니다. (세션 기반 인증)
    -   [ ] 로그인한 사용자는 자신의 정보를 조회할 수 있어야 합니다.

2.  **계좌 관리**
    -   [ ] 사용자는 자신의 계좌를 개설할 수 있어야 합니다. **이때 계좌번호는 시스템에서 자동으로 생성 및 부여합니다.**
    -   [ ] 사용자는 자신의 계좌 목록과 각 계좌의 잔액을 조회할 수 있어야 합니다.
    -   [ ] 계좌는 활성(ACTIVE), 비활성(INACTIVE), 해지(CLOSED) 상태를 가져야 하며, 비활성/해지 상태의 계좌에서는 거래가 발생할 수 없습니다.

3.  **타행 송금**
    -   [ ] 사용자는 등록된 타행 목록에서 은행을 선택하고, 계좌번호와 금액을 입력하여 송금을 요청할 수 있어야 합니다.
    -   [ ] 송금 요청 시, 출금 계좌의 잔액이 송금액보다 적으면 요청은 실패해야 합니다. (잔액 부족)
    -   [ ] 송금 요청 시, `external-bank` 서비스와 통신하여 수취인 계좌의 유효성을 검증해야 합니다.
        -   [ ] 계좌가 존재하지 않거나, 해지된 상태일 경우 요청은 실패해야 합니다.
    -   [ ] 계좌 유효성 검증이 성공하면, 출금 계좌에서 금액을 차감하고 거래(Transaction)를 `REQUESTED` 상태로 생성해야 합니다.
    -   [ ] `external-bank`에 실제 송금(입금)을 요청하고, 성공적으로 처리되었다는 응답을 받으면 거래를 `SUCCESS` 상태로 변경해야 합니다.
    -   [ ] `external-bank`에서 실패 응답을 받거나, 통신에 문제가 발생하면 거래를 `FAILED` 상태로 변경하고, 차감했던 금액을 다시 출금 계좌로 복구(롤백)해야 합니다. (Transaction 보상)

4.  **거래 내역 조회**
    -   [ ] 사용자는 특정 계좌의 모든 거래 내역(입금, 출금, 송금)을 최신순으로 조회할 수 있어야 합니다.

5.  **지원 은행 관리 (Admin 기능)**
    -   [ ] 관리자는 송금 가능한 은행을 추가, 수정, 비활성화할 수 있어야 합니다.

### 비기능적 요구사항 (Non-functional Requirements)

1.  **보안 (Security)**
    -   사용자의 비밀번호는 반드시 암호화(Hashing)하여 데이터베이스에 저장해야 합니다.
    -   모든 API 요청은 인증(Authentication)을 거쳐야 하며, 인가(Authorization)된 사용자만 자신의 정보에 접근할 수 있어야 합니다.
    -   API 통신은 HTTPS를 통해 암호화되어야 합니다.

2.  **안정성 및 데이터 정합성 (Reliability & Consistency)**
    -   어떠한 경우에도 사용자의 자산(잔액)이 유실되어서는 안 됩니다. 송금 프로세스의 모든 단계에서 데이터 정합성을 보장해야 합니다.
    -   동시에 여러 송금 요청이 발생하더라도 잔액이 정확하게 계산되어야 합니다. (동시성 제어)
    -   외부 서비스(`external-bank`)의 장애가 `banking-service`의 핵심 기능(잔액 조회 등)에 영향을 주어서는 안 됩니다. (장애 격리)

3.  **성능 (Performance)**
    -   사용자의 잔액 조회 및 거래 내역 조회 API는 200ms 이내에 응답해야 합니다.
    -   송금 요청 API는 외부 은행 통신 시간을 제외하고 500ms 이내에 처리되어야 합니다.

4.  **코드 품질 (Code Quality)**
    -   모든 비즈니스 로직에는 단위 테스트(Unit Test) 및 통합 테스트(Integration Test) 코드가 작성되어야 합니다.
    -   코드는 명확하고 이해하기 쉬운 컨벤션을 따라야 하며, 적절한 주석과 문서가 동반되어야 합니다.

---

## external-bank 개발 요구사항

`external-bank`는 `banking-service`가 타행 송금을 요청할 때, 그 요청을 받아 처리하는 외부 은행 시스템의 역할을 시뮬레이션합니다. 이 서비스는 독립적으로 실행되며, 미리 정의된 테스트용 계좌 데이터를 가지고 있습니다.

### 기능적 요구사항 (Functional Requirements)

1.  **테스트용 계좌 관리**
    -   [ ] 서비스는 시작 시점에 미리 정의된 몇 개의 가상 계좌를 메모리 또는 데이터베이스에 로드해야 합니다. (예: 신한은행 `888-777-666666`, 잔액 50,000원)
    -   [ ] 각 계좌는 `은행 코드`, `계좌 번호`, `예금주명`, `잔액`, `상태(ACTIVE, CLOSED)` 정보를 가집니다.

2.  **계좌 유효성 검증 API**
    -   [ ] `banking-service`로부터 `은행 코드`와 `계좌 번호`를 받아 해당 계좌가 존재하는지, 그리고 `ACTIVE` 상태인지 확인하는 API를 제공해야 합니다. (`GET /api/v1/accounts/{bankCode}/{accountNumber}/verify`)
    -   [ ] 계좌가 유효하면 예금주명을 포함한 성공 응답을 반환합니다.
    -   [ ] 계좌가 존재하지 않거나 `CLOSED` 상태이면, 명확한 에러 코드를 포함한 실패 응답을 반환합니다.

3.  **입금 처리 API**
    -   [ ] `banking-service`로부터 `은행 코드`, `계좌 번호`, `입금액`을 받아 해당 계좌의 잔액을 증가시키는 API를 제공해야 합니다. (`POST /api/v1/accounts/deposit`)
    -   [ ] 입금이 성공하면, 처리된 거래 정보를 포함한 성공 응답을 반환합니다.
    -   [ ] 대상 계좌가 유효하지 않으면 실패 응답을 반환합니다.

### 비기능적 요구사항 (Non-functional Requirements)

1.  **장애 상황 시뮬레이션**
    -   [ ] 특정 계좌번호나 특정 조건 하에서 의도적으로 응답을 지연시키거나 실패 응답(500 Internal Server Error)을 반환하는 기능을 포함하여, `banking-service`의 타임아웃 및 보상 트랜잭션 로직을 테스트할 수 있도록 지원해야 합니다. (선택 사항)
2.  **독립성**
    -   `external-bank`는 `banking-service`에 대한 어떠한 의존성도 가지지 않아야 합니다. 오직 정의된 API를 통해서만 통신합니다.


